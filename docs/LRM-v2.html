<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LRM-v2</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><h2 id="quark-language-reference-manual">Quark Language Reference Manual</h2>

<table>
<thead>
<tr>
  <th align="left">Name</th>
  <th align="left">UNI</th>
</tr>
</thead>
<tbody><tr>
  <td align="left">Daria Jung</td>
  <td align="left">djj2115</td>
</tr>
<tr>
  <td align="left">Jamis Johnson</td>
  <td align="left">jmj2180</td>
</tr>
<tr>
  <td align="left">Jim Fan</td>
  <td align="left">lf2422</td>
</tr>
<tr>
  <td align="left">Parthiban Loganathan</td>
  <td align="left">pl2487</td>
</tr>
</tbody></table>


<h2 id="table-of-contents">Table of contents</h2>

<p><div class="toc"><div class="toc">
<ul>
<li><ul>
<li><a href="#quark-language-reference-manual">Quark Language Reference Manual</a></li>
<li><a href="#table-of-contents">Table of contents</a><ul>
<li><a href="#introduction">Introduction</a></li>
</ul>
</li>
<li><a href="#reference-manual">Reference Manual</a><ul>
<li><a href="#grammar-notation">Grammar Notation</a></li>
<li><a href="#lexical-conventions">Lexical Conventions</a></li>
<li><a href="#line-terminators">Line Terminators</a></li>
<li><a href="#comments">Comments</a></li>
<li><a href="#whitespace">Whitespace</a></li>
<li><a href="#tokens">Tokens</a></li>
<li><a href="#identifiers">Identifiers</a></li>
<li><a href="#keywords">Keywords</a></li>
<li><a href="#punctuation">Punctuation</a></li>
<li><a href="#escape-sequences">Escape Sequences</a></li>
<li><a href="#data-types">Data Types</a><ul>
<li><a href="#int">int</a></li>
<li><a href="#float">float</a></li>
<li><a href="#fraction">fraction</a></li>
<li><a href="#bool">bool</a></li>
<li><a href="#complex">complex</a></li>
<li><a href="#string">string</a></li>
<li><a href="#qreg">qreg</a></li>
<li><a href="#matrix">matrix</a></li>
<li><a href="#array">array</a></li>
<li><a href="#void">void</a></li>
</ul>
</li>
<li><a href="#function-types">Function types</a></li>
<li><a href="#declarations">Declarations</a><ul>
<li><a href="#declaring-a-variable">Declaring a Variable</a></li>
<li><a href="#declaring-an-array">Declaring an Array</a></li>
<li><a href="#declaring-a-matrix">Declaring a Matrix</a></li>
</ul>
</li>
<li><a href="#operators">Operators</a><ul>
<li><a href="#arithmetic">Arithmetic</a></li>
<li><a href="#concatenation">Concatenation</a></li>
<li><a href="#assignment">Assignment</a></li>
<li><a href="#logical">Logical</a></li>
<li><a href="#bitwise-logical-unary">Bitwise Logical / Unary</a></li>
<li><a href="#quantum">Quantum</a></li>
<li><a href="#operator-precedence-and-associativity">Operator Precedence and Associativity</a></li>
</ul>
</li>
<li><a href="#statements">Statements</a></li>
<li><a href="#blocks">Blocks</a></li>
<li><a href="#return-statement">Return Statement</a></li>
<li><a href="#if-else-statement">If else Statement</a></li>
<li><a href="#while-loop">While Loop</a></li>
<li><a href="#for-statement">For Statement</a><ul>
<li><a href="#array-iterator">Array Iterator</a></li>
<li><a href="#range-iterator">Range Iterator</a></li>
</ul>
</li>
<li><a href="#break-and-continue">Break and Continue</a></li>
<li><a href="#functions">Functions</a><ul>
<li><a href="#function-declaration">Function Declaration</a></li>
</ul>
</li>
<li><a href="#overloading">Overloading</a></li>
<li><a href="#grammar">Grammar</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</p>



<h3 id="introduction">Introduction</h3>

<p>This is the language reference manual for Quark, a high level language for quantum computing. Quark makes it simple to perform complicated mathematical operations required for quantum computing in a simple and intuitive manner. In addition to standard types featured in most common programming languages, Quark supports complex numbers, fractions, matrices and quantum registers.</p>



<h2 id="reference-manual">Reference Manual</h2>



<h3 id="grammar-notation">Grammar Notation</h3>

<p>FILL OUT LATER</p>



<h3 id="lexical-conventions">Lexical Conventions</h3>

<p>A program in QUARK includes at least one function definition, though something trivial like a variable declaration or a string should compile. Programs are written using a basic source character set accepted by the C++ compiler in use. Refer to what source-code file encoding your compiler accepts. The QUARK compiler will only output ASCII.</p>



<h3 id="line-terminators">Line Terminators</h3>

<p>?</p>



<h3 id="comments">Comments</h3>

<p>MATLAB style commenting is supported. A MATLAB style comment begins with <code>%</code> and ends with <code>%</code>. Multi-line MATLAB comments start with <code>%{</code> and end with <code>}%</code>. Any sequence of characters can appear inside of a comment except the string <code>}%</code>. These comments do not nest. </p>



<h3 id="whitespace">Whitespace</h3>

<p>Whitespace is defined as the ASCII space, horizontal tab and form feed characters, as well as line terminators and comments.</p>



<h3 id="tokens">Tokens</h3>

<p>Tokens in QUARK consist of identifiers, keywords, constants, and separators. Whitespace is ignored and not taken into consideration.</p>



<h3 id="identifiers">Identifiers</h3>

<p>An identifier is composed of a sequence of letters and digits, the first of which must be a letter. There is no limit on the length of an identifier. The underscore character <code>_</code> is included in the regular expression pattern for letters. </p>

<p>Two identifiers are the same if they have the same ASCII character for every letter and digit. </p>



<pre class="prettyprint"><code class=" hljs coffeescript">digit<span class="hljs-function"> -&gt;</span> [<span class="hljs-string">'0'</span>-<span class="hljs-string">'9'</span>]
letter<span class="hljs-function"> -&gt;</span> [<span class="hljs-string">'a'</span>-<span class="hljs-string">'z'</span> <span class="hljs-string">'A'</span>-<span class="hljs-string">'Z'</span> <span class="hljs-string">'_'</span>]
Identifier<span class="hljs-function"> -&gt;</span> letter (letter | digit)* </code></pre>



<h3 id="keywords">Keywords</h3>

<p>The following identifiers are reserved for use as keywords, and may not be used otherwise:</p>

<blockquote>
  <p>def <br>
  bool <br>
  int <br>
  float <br>
  fraction <br>
  complex <br>
  qreg <br>
  void <br>
  mod <br>
  in <br>
  return <br>
  continue <br>
  break <br>
  while <br>
  for <br>
  else <br>
  if <br>
  and <br>
  not <br>
  or</p>
</blockquote>

<h3 id="punctuation">Punctuation</h3>

<p><strong>Parenthesis</strong> – Expressions can include expressions inside parenthesis. Parenthesis can also indicate a function call.</p>

<p><strong>Braces</strong> – Braces indicate a block of statements.</p>

<p><strong>Semicolon</strong> – Semicolons are used at the end of every statement as a terminator. Semicolons are also used to separate rows in the matrix data type.</p>

<p><strong>Colon</strong> – Colons are used to denote slicing in arrays and within a function declaration. In a function declaration, formal arguments appear between the colon and a left curly brace. </p>

<p><strong>Dollar Sign</strong> – The dollar sign separates the numerator value from the denominator value in a fraction data type.</p>

<p><strong>Comma</strong> – Commas have several use cases. Commas are used to separate formal arguments in a function declaration, elements in arrays and matrices, and the size and initial state of a <code>qreg</code>.</p>



<h3 id="escape-sequences">Escape Sequences</h3>

<p>Certain characters within strings need to be preceded by a backslash. These characters and the sequences to produce them in a string are:</p>

<table>
<thead>
<tr>
  <th align="center">Character</th>
  <th align="left">Sequence</th>
</tr>
</thead>
<tbody><tr>
  <td align="center">\”</td>
  <td align="left">“</td>
</tr>
<tr>
  <td align="center">\n</td>
  <td align="left">linefeed</td>
</tr>
<tr>
  <td align="center">\r</td>
  <td align="left">carriage return</td>
</tr>
<tr>
  <td align="center">\t</td>
  <td align="left">horizontal tabulation</td>
</tr>
<tr>
  <td align="center">\b</td>
  <td align="left">backspace</td>
</tr>
</tbody></table>


<h3 id="data-types">Data Types</h3>

<p>The data types available in QUARK are:</p>

<blockquote>
  <p>int <br>
  float <br>
  fraction <br>
  bool <br>
  complex <br>
  string <br>
  qreg <br>
  matrix <br>
  void</p>
</blockquote>

<p>Additionally, the aggregate data type of array is available to the user.</p>



<h4 id="int">int</h4>

<p>An <code>int</code> is a 64-bit signed integer.</p>



<h4 id="float">float</h4>

<p>A <code>float</code> is a 64-bit signed floating-point number.</p>



<h4 id="fraction">fraction</h4>

<p>A <code>fraction</code> is denoted by two <code>int</code> types separated by <code>$</code>. </p>



<h4 id="bool">bool</h4>

<p>A <code>bool</code> value is denoted using the literals <code>true</code> or <code>false</code>.</p>



<h4 id="complex">complex</h4>

<p>A <code>complex</code> type is generated from two <code>int</code> or <code>float</code> values; if given a mix of <code>int</code> and <code>float</code> types, QUARK will implicitly type cast. A <code>complex</code> type can also be generated with one numerical value, which will be assigned to the real part of a complex number; imaginary will default to 0. The real and imaginary parts of a complex number can be accessed by <code>real</code> and <code>im</code> accessors.</p>



<pre class="prettyprint"><code class="language-ocaml hljs ">complex cnum = i(<span class="hljs-number">3.0</span>, <span class="hljs-number">1</span>);
real(cnum); % <span class="hljs-number">3.0</span>
im(cnum); % <span class="hljs-number">1</span>
complex cnum2 = i(<span class="hljs-number">9</span>) % this gives us i(<span class="hljs-number">9</span>, <span class="hljs-number">0</span>)</code></pre>



<h4 id="string">string</h4>

<p>A <code>string</code> is a sequence of characters. String literals are placed between double quotations.</p>



<h4 id="qreg">qreg</h4>

<p>A <code>qreg</code> type represents a quantum register. A <code>qreg</code> accepts two <code>int</code> types. The left value denotes the initial size of a quantum register, and the right value denotes the initial bit.</p>



<pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">qreg q </span>=<span class="hljs-string"> &lt;| 1, 1 |&gt;;</span></code></pre>

<p>Qreg must be passed as an LValue to any function:</p>

<pre class="prettyprint"><code class=" hljs matlab"><span class="hljs-comment">% disallowed</span>
<span class="hljs-built_in">hadamard</span>(&lt;|<span class="hljs-number">10</span>, <span class="hljs-number">3</span>|&gt;); 

<span class="hljs-comment">% allowed</span>
qreg q = &lt;|<span class="hljs-number">10</span>, <span class="hljs-number">3</span>|&gt;;
<span class="hljs-built_in">hadamard</span>(q);</code></pre>

<p>Additionally, qreg values may be measured using the <code>?</code> operator, and the <code>?</code> operator may only operate on an LValue of type qreg.</p>

<p>The <code>?</code> operator may only be invoked on an LValue.</p>

<pre class="prettyprint"><code class="language-matlab hljs ">q ? <span class="hljs-matrix">[<span class="hljs-number">2</span>:<span class="hljs-number">10</span>]</span>;  <span class="hljs-comment">% measures qubit 2 to 10</span></code></pre>

<h4 id="matrix">matrix</h4>

<p>QUARK allows you to create matrices; a <code>matrix</code> uses a special bracket notation to distinguish from arrays, and rows are separated by semicolons. Matrices may be composed of only <code>int</code>, <code>float</code>, or <code>complex</code>. Matrix elements may be accessed with a square bracket notation by separating the column and row index numbers by commas.</p>



<pre class="prettyprint"><code class=" hljs lua">float<span class="hljs-string">[[]]</span> mat = [| <span class="hljs-number">1.2</span>, <span class="hljs-number">3.4</span>; <span class="hljs-number">5.6</span>, <span class="hljs-number">7.8</span> |];
mat[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>];</code></pre>



<h4 id="array">array</h4>

<p>QUARK allows arrays of any of the above data types. Arrays are of variable length and are arbitrarily dimensional. </p>

<p>Arrays can be initialized using a comma-separated list delimited by square brackets [ ]. Additionally, arrays can be declared with a size to create an array of uninitialized elements. </p>

<p>Arrays may be concatenated with the <code>&amp;</code> operator as long as there is a dimension and type match. </p>



<pre class="prettyprint"><code class=" hljs lua">int[<span class="hljs-number">5</span>]; % gives us [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]
int[] a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; % array initialization
int[][] b = <span class="hljs-string">[[1,2,3], [4,5,6]]</span>; % <span class="hljs-number">2</span>-d array

[<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>] &amp; int[<span class="hljs-number">3</span>]
% gives us [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]</code></pre>

<p>Array indices can be accessed using the square bracket notation with an integer such as:</p>



<pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">int[] arr </span>=<span class="hljs-string"> [0, 1, 2];
arr[0]; </span></code></pre>

<p>or</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">int</span>[] arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
arr[i];</code></pre>

<p>Indices of multidimensional arrays may be accessed by separating the dimensional index numbers by commas:</p>



<pre class="prettyprint"><code class="language-matlab hljs ">int<span class="hljs-matrix">[]</span><span class="hljs-matrix">[]</span> arr = <span class="hljs-matrix">[[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]</span>,<span class="hljs-matrix">[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]</span>]
arr<span class="hljs-matrix">[<span class="hljs-number">1</span>]</span><span class="hljs-matrix">[<span class="hljs-number">1</span>]</span>; <span class="hljs-comment">% accesses 4</span></code></pre>

<p>The built-in <code>len</code> function returns an <code>int</code> representing the length of the array.</p>

<p>Membership may be tested using the keyword <code>in</code>. </p>



<h4 id="void">void</h4>

<p>Void is a type for a function that returns normally, but does not provide a result value to the caller.</p>



<h3 id="function-types">Function types</h3>

<p>Functions take in zero or more variables of primitive or array types and optionally return a variable of primitive or array type. A function declaration always begins with <code>def</code>, the return type of the function, a colon <code>:</code>, and a list of formal parameters which may be empty.</p>



<pre class="prettyprint"><code class=" hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">void</span> <span class="hljs-title">main</span>:</span> int x
{
    % statement
}</code></pre>



<h3 id="declarations">Declarations</h3>



<h4 id="declaring-a-variable">Declaring a Variable</h4>

<p>Variables can be defined within individual functions or in the global scope. Variables may be declared and then defined, or declared and defined simultaneously. An expression to which a value may be assigned is called an LValue.</p>



<pre class="prettyprint"><code class=" hljs perl"><span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span>; % definition
<span class="hljs-keyword">x</span> = <span class="hljs-number">5</span>; % declaration
<span class="hljs-keyword">int</span> <span class="hljs-keyword">y</span> = <span class="hljs-number">6</span>; % definition <span class="hljs-keyword">and</span> declaration</code></pre>

<p>x and y are LValues. LValues are named as such because they can appear on the left side of an assignment (though they may also appear on the right side).</p>



<h4 id="declaring-an-array">Declaring an Array</h4>

<p>As previously shown, arrays can be multidimensional, and may be of variable length. Arrays may be declared on their own with a size to get an uninitialized array of the given size. They can also be initialized with values upon declaration.</p>



<pre class="prettyprint"><code class=" hljs lua">int[<span class="hljs-number">5</span>]; % gives us [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]
int[] a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; % array initialization
int[][] b = <span class="hljs-string">[[1,2,3], [4,5,6]]</span>; % <span class="hljs-number">2</span>-d array</code></pre>



<h4 id="declaring-a-matrix">Declaring a Matrix</h4>

<p>A matrix declaration uses the special notation of piped square brackets. Matrix rows are distinguished using the <code>;</code> separator between elements of rows. Initializing an empty complex matrix initializes an all-zero 3-by-4 complex matrix.</p>



<pre class="prettyprint"><code class="language-matlab hljs ">float<span class="hljs-matrix">[|]</span> floatmat = <span class="hljs-matrix">[| <span class="hljs-number">1.2</span>, <span class="hljs-number">3.4</span>; <span class="hljs-number">5.6</span>, <span class="hljs-number">7.8</span> |]</span>;
<span class="hljs-built_in">complex</span><span class="hljs-matrix">[|]</span> mat; <span class="hljs-comment">% this gives us complex[| 3, 4 |]</span></code></pre>



<h3 id="operators">Operators</h3>



<h4 id="arithmetic">Arithmetic</h4>

<table>
<thead>
<tr>
  <th align="left">Operator</th>
  <th align="right"></th>
</tr>
</thead>
<tbody><tr>
  <td align="left"><code>+</code></td>
  <td align="right">addition</td>
</tr>
<tr>
  <td align="left"><code>-</code></td>
  <td align="right">subtraction</td>
</tr>
<tr>
  <td align="left"><code>++</code></td>
  <td align="right">unary increment by one</td>
</tr>
<tr>
  <td align="left"><code>--</code></td>
  <td align="right">unary decrement by one</td>
</tr>
<tr>
  <td align="left"><code>/</code></td>
  <td align="right">division</td>
</tr>
<tr>
  <td align="left"><code>*</code></td>
  <td align="right">multiplication</td>
</tr>
<tr>
  <td align="left"><code>mod</code></td>
  <td align="right">modulo</td>
</tr>
<tr>
  <td align="left"><code>**</code></td>
  <td align="right">power</td>
</tr>
</tbody></table>


<h4 id="concatenation">Concatenation</h4>

<table>
<thead>
<tr>
  <th align="left">Operator</th>
  <th align="right"></th>
</tr>
</thead>
<tbody><tr>
  <td align="left"><code>&amp;</code></td>
  <td align="right">String and array concatenation</td>
</tr>
</tbody></table>




<h4 id="assignment">Assignment</h4>

<table>
<thead>
<tr>
  <th align="left">Operator</th>
  <th align="right"></th>
</tr>
</thead>
<tbody><tr>
  <td align="left"><code>=</code></td>
  <td align="right">assigns value or right hand side to left hand side</td>
</tr>
<tr>
  <td align="left"><code>+=</code></td>
  <td align="right">addition assignment</td>
</tr>
<tr>
  <td align="left"><code>-=</code></td>
  <td align="right">subtraction assignment</td>
</tr>
<tr>
  <td align="left"><code>*=</code></td>
  <td align="right">multiplication assignment</td>
</tr>
<tr>
  <td align="left"><code>/=</code></td>
  <td align="right">division assignment</td>
</tr>
<tr>
  <td align="left"><code>&amp;=</code></td>
  <td align="right">bitand assignment</td>
</tr>
</tbody></table>


<p>Assignment has right to left precedence.</p>



<h4 id="logical">Logical</h4>

<table>
<thead>
<tr>
  <th align="left">Operator</th>
  <th align="right"></th>
</tr>
</thead>
<tbody><tr>
  <td align="left"><code>!=</code></td>
  <td align="right">not equal to</td>
</tr>
<tr>
  <td align="left"><code>==</code></td>
  <td align="right">equal to</td>
</tr>
<tr>
  <td align="left"><code>&gt;</code></td>
  <td align="right">greater than</td>
</tr>
<tr>
  <td align="left"><code>&gt;=</code></td>
  <td align="right">greater than or equal to</td>
</tr>
<tr>
  <td align="left"><code>&lt;</code></td>
  <td align="right">less than</td>
</tr>
<tr>
  <td align="left"><code>&lt;=</code></td>
  <td align="right">less than or equal to</td>
</tr>
<tr>
  <td align="left"><code>and</code></td>
  <td align="right">unary and</td>
</tr>
<tr>
  <td align="left"><code>or</code></td>
  <td align="right">unary or</td>
</tr>
<tr>
  <td align="left"><code>not</code></td>
  <td align="right">unary not</td>
</tr>
</tbody></table>




<h4 id="bitwise-logical-unary">Bitwise Logical / Unary</h4>

<table>
<thead>
<tr>
  <th align="left">Operator</th>
  <th align="right"></th>
</tr>
</thead>
<tbody><tr>
  <td align="left"><code>~</code></td>
  <td align="right">Bitwise not</td>
</tr>
<tr>
  <td align="left"><code>&amp;</code></td>
  <td align="right">Bitwise and</td>
</tr>
<tr>
  <td align="left"><code>^</code></td>
  <td align="right">Bitwise xor</td>
</tr>
<tr>
  <td align="left"><code>|</code></td>
  <td align="right">Bitwise or</td>
</tr>
<tr>
  <td align="left"><code>&lt;&lt;</code></td>
  <td align="right">Bitwise left shift</td>
</tr>
<tr>
  <td align="left"><code>&gt;&gt;</code></td>
  <td align="right">Bitwise right shift</td>
</tr>
</tbody></table>




<h4 id="quantum">Quantum</h4>

<table>
<thead>
<tr>
  <th align="left">Operator</th>
  <th align="right"></th>
</tr>
</thead>
<tbody><tr>
  <td align="left"><code>?</code></td>
  <td align="right">quantum measurement query</td>
</tr>
</tbody></table>


<p>The <code>?</code> operator may only be invoked on an LValue.</p>



<pre class="prettyprint"><code class="language-matlab hljs ">q ? <span class="hljs-matrix">[<span class="hljs-number">2</span>:<span class="hljs-number">10</span>]</span>;  <span class="hljs-comment">% measures qubit 2 to 10</span></code></pre>



<h4 id="operator-precedence-and-associativity">Operator Precedence and Associativity</h4>

<table>
<thead>
<tr>
  <th align="left">Operator</th>
  <th align="right">Associativity</th>
</tr>
</thead>
<tbody><tr>
  <td align="left"><code>*</code> <code>/</code> <code>mod</code></td>
  <td align="right">left</td>
</tr>
<tr>
  <td align="left"><code>+</code> <code>-</code></td>
  <td align="right">left</td>
</tr>
<tr>
  <td align="left"><code>&gt;&gt;</code> <code>&lt;&lt;</code></td>
  <td align="right">left</td>
</tr>
<tr>
  <td align="left"><code>&gt;</code> <code>&gt;=</code> <code>&lt;</code> <code>&lt;=</code></td>
  <td align="right">left</td>
</tr>
<tr>
  <td align="left"><code>==</code> <code>!=</code></td>
  <td align="right">left</td>
</tr>
<tr>
  <td align="left"><code>&amp;</code></td>
  <td align="right">left</td>
</tr>
<tr>
  <td align="left"><code>^</code></td>
  <td align="right">left</td>
</tr>
<tr>
  <td align="left"><code>|</code></td>
  <td align="right">left</td>
</tr>
<tr>
  <td align="left"><code>and</code></td>
  <td align="right">left</td>
</tr>
<tr>
  <td align="left"><code>or</code></td>
  <td align="right">left</td>
</tr>
<tr>
  <td align="left"><code>?</code></td>
  <td align="right">right</td>
</tr>
<tr>
  <td align="left"><code>in</code></td>
  <td align="right">left</td>
</tr>
<tr>
  <td align="left"><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>&amp;=</code></td>
  <td align="right">right</td>
</tr>
</tbody></table>


<p>Operators within the same row share the same precedence. Higher rows indicate higher precedence.</p>



<h3 id="statements">Statements</h3>

<p>Statements are the smallest components of a program used to express that an action is to be carried out. Statements are used for variable declarations and assignment, control flow, loops, function calls, and expressions. All statements end with a semicolon <code>;</code>. Statements are used within blocks. The following are examples of statements and are by no means exhaustive:</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">string</span> hello = <span class="hljs-string">"hello world"</span>;
<span class="hljs-keyword">int</span> x = <span class="hljs-number">10</span>;
<span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">5</span>
foo(<span class="hljs-number">4</span>);
<span class="hljs-keyword">while</span> x != <span class="hljs-keyword">true</span>
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>:<span class="hljs-number">10</span>]
<span class="hljs-number">4</span> + <span class="hljs-number">6</span>
qreg q0 = &lt;| nbit * <span class="hljs-number">2</span>, <span class="hljs-number">0</span> |&gt;;</code></pre>



<h3 id="blocks">Blocks</h3>

<p>A block is defined to be inside curly braces <code>{ }</code>, which may include empty statements and variable declarations. </p>

<p>A block looks like: </p>



<pre class="prettyprint"><code class=" hljs haml">{
<span class="hljs-tag">    %</span> statements here
}</code></pre>



<h3 id="return-statement">Return Statement</h3>

<p>The return keyword accepts an expression, and exits out of the nearest calling block or smallest containing function.</p>



<h3 id="if-else-statement">If else Statement</h3>

<p>If statements take expressions that reduce to a boolean, and followed by a colon <code>:</code> and a statement block. If the following statement is only one line, curly braces are unnecessary. </p>



<pre class="prettyprint"><code class=" hljs matlab"><span class="hljs-keyword">if</span> p == <span class="hljs-number">1</span>:
    <span class="hljs-keyword">return</span> a;

<span class="hljs-keyword">if</span> (<span class="hljs-number">3</span> &gt; <span class="hljs-number">1</span>):
<span class="hljs-cell">{
    % multiple statements
}</span></code></pre>



<h3 id="while-loop">While Loop</h3>

<p>A while loop is of the form:</p>



<pre class="prettyprint"><code class=" hljs mel"><span class="hljs-keyword">while</span>(<span class="hljs-keyword">condition</span>): 
{
    % statement
}</code></pre>

<p>As with <code>if else</code> statements, if the following statement is only one line, curly braces <code>{}</code> are unnecessary.</p>



<pre class="prettyprint"><code class=" hljs matlab"><span class="hljs-keyword">while</span> exp_mod(b, <span class="hljs-built_in">i</span>, M) != <span class="hljs-number">1</span>:
    <span class="hljs-built_in">i</span> ++;</code></pre>

<p>The condition of the while loop may not be empty.</p>



<h3 id="for-statement">For Statement</h3>

<p>QUARK supports two types of iterators, array and range, for its for statements.</p>

<h4 id="array-iterator">Array Iterator</h4>

<p>An array iterator allows you to sweep a variable across an array, evaluating the inner statement with identifiers assigned to a new value before each iteration. The identifier after <code>for</code> is assigned to the value of each element of the array sequentially.</p>

<p>The identifier may be declared ahead of time or within the for statement itself.</p>

<pre class="prettyprint"><code class=" hljs matlab">int<span class="hljs-matrix">[]</span> arr = <span class="hljs-matrix">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]</span>;
<span class="hljs-keyword">for</span> int <span class="hljs-built_in">i</span> in arr:
    print <span class="hljs-built_in">i</span>;

<span class="hljs-comment">% 1</span>
<span class="hljs-comment">% 2</span>
<span class="hljs-comment">% 3</span></code></pre>



<h4 id="range-iterator">Range Iterator</h4>

<p>A range iterator allows you to sweep a variable across an array, evaluating the inner statement with identifiers assigned to a new value before each iteration. The identifier after <code>for</code> is assigned to each integer in the range.</p>

<p>The identifier may be declared ahead of time or within the for statement itself.</p>

<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">int</span> i;
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>:<span class="hljs-number">10</span>]
<span class="hljs-keyword">for</span> <span class="hljs-keyword">int</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>:<span class="hljs-number">10</span>:<span class="hljs-number">2</span>]</code></pre>

<p>A range consists of three integers separated by colons <code>[start : stop : step]</code>. Start denotes the start of the range, stop denotes the exclusive end of a range, and step denotes the step size of the range. If the step and the last colon is excluded, the step is defaulted to 1. If the start value is excluded, it is defaulted to 0. </p>

<p>The following are various ways of declaring ranges:</p>

<pre class="prettyprint"><code class="language-matlab hljs "><span class="hljs-number">0</span>:<span class="hljs-number">5</span>:<span class="hljs-number">2</span> <span class="hljs-comment">% this gives us 0, 2, 4</span>
:<span class="hljs-number">5</span> <span class="hljs-comment">% 0, 1, 2, 3, 4</span>
<span class="hljs-number">1</span>:<span class="hljs-number">3</span> <span class="hljs-comment">% 1, 2</span></code></pre>



<h3 id="break-and-continue">Break and Continue</h3>

<p>The <code>break</code> statement causes a while loop or for loop to terminate. </p>

<p>The <code>continue</code> statement provides a way to jump back to the top of a loop earlier than normal; it may be used to bypass the remainder of a loop for an iteration.</p>

<h3 id="functions">Functions</h3>

<p>QUARK allows users to define functions. </p>



<h4 id="function-declaration">Function Declaration</h4>

<p>Functions are composed of the form:</p>



<pre class="prettyprint"><code class=" hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">return_type</span> <span class="hljs-title">func_name</span>:</span> type arg1, type arg2 
{
    % statements <span class="hljs-keyword">in</span> function body

    <span class="hljs-keyword">return</span> return_type
}</code></pre>

<p>Functions are defined only by identifying the block of code and the keyword <code>def</code>, giving the function a name, supplying it with zero or more formal arguments, and defining a function body. Function return types are of any data type previously described, or <code>void</code> for no value.</p>

<p>Some examples of function declarations are:</p>



<pre class="prettyprint"><code class=" hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">void</span> <span class="hljs-title">hello</span>:</span> 
{
    print(<span class="hljs-string">"hello world"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">int</span> <span class="hljs-title">addition</span>:</span> int x, int y
{
    <span class="hljs-keyword">return</span> x + y;
}</code></pre>



<h3 id="overloading">Overloading</h3>



<h3 id="grammar">Grammar</h3>

<p>Below is the grammar for QUARK. Words in capital letters are tokens passed in from the lexer.</p>

<pre class="prettyprint"><code class="language-ocaml hljs ">ident:
    ID { Ident($<span class="hljs-number">1</span>) }

vartype:
    INT      { Int }
  | FLOAT    { Float }
  | BOOLEAN  { Bool }
  | STRING   { String }
  | QREG     { Qreg }
  | FRACTION { Fraction }
  | COMPLEX  { Complex }
  | VOID     { Void }

datatype:
  | vartype { DataType($<span class="hljs-number">1</span>) }
  | datatype LSQUARE RSQUARE { ArrayType($<span class="hljs-number">1</span>) }
  | datatype LMATRIX RSQUARE { MatrixType($<span class="hljs-number">1</span>) } <span class="hljs-comment">/* int[|] */</span>

<span class="hljs-comment">/* Variables that can be assigned a value */</span>
lvalue:
  | ident                        { Variable($<span class="hljs-number">1</span>) }
  | ident LSQUARE expr_list RSQUARE 
      { ArrayElem($<span class="hljs-number">1</span>, $<span class="hljs-number">3</span>)}

expr:
  <span class="hljs-comment">/* Logical */</span>
  | expr LT expr          { Binop($<span class="hljs-number">1</span>, Less, $<span class="hljs-number">3</span>) }
  | expr LTE expr         { Binop($<span class="hljs-number">1</span>, LessEq, $<span class="hljs-number">3</span>) }
  | expr GT expr          { Binop($<span class="hljs-number">1</span>, Greater, $<span class="hljs-number">3</span>) }
  | expr GTE expr         { Binop($<span class="hljs-number">1</span>, GreaterEq, $<span class="hljs-number">3</span>) }
  | expr EQUALS expr      { Binop($<span class="hljs-number">1</span>, Eq, $<span class="hljs-number">3</span>) }
  | expr NOT_EQUALS expr  { Binop($<span class="hljs-number">1</span>, NotEq, $<span class="hljs-number">3</span>) }
  | expr AND expr         { Binop($<span class="hljs-number">1</span>, And, $<span class="hljs-number">3</span>) }
  | expr OR expr          { Binop($<span class="hljs-number">1</span>, Or, $<span class="hljs-number">3</span>) }

  <span class="hljs-comment">/* Unary */</span>
  | BITNOT expr             { Unop(BitNot, $<span class="hljs-number">2</span>) }
  | MINUS expr %prec UMINUS { Unop(Neg, $<span class="hljs-number">2</span>) }
  | NOT expr                { Unop(Not, $<span class="hljs-number">2</span>) }

  <span class="hljs-comment">/* Arithmetic */</span>
  | expr PLUS expr    { Binop($<span class="hljs-number">1</span>, Add, $<span class="hljs-number">3</span>) }
  | expr MINUS expr   { Binop($<span class="hljs-number">1</span>, Sub, $<span class="hljs-number">3</span>) }
  | expr TIMES expr   { Binop($<span class="hljs-number">1</span>, Mul, $<span class="hljs-number">3</span>) }
  | expr DIVIDE expr  { Binop($<span class="hljs-number">1</span>, Div, $<span class="hljs-number">3</span>) }
  | expr MODULO expr  { Binop($<span class="hljs-number">1</span>, Mod, $<span class="hljs-number">3</span>) }
  | expr POWER expr   { Binop($<span class="hljs-number">1</span>, Pow, $<span class="hljs-number">3</span>) }

  <span class="hljs-comment">/* Bitwise */</span>
  | expr BITAND expr        { Binop($<span class="hljs-number">1</span>, BitAnd, $<span class="hljs-number">3</span>) }
  | expr BITXOR expr        { Binop($<span class="hljs-number">1</span>, BitXor, $<span class="hljs-number">3</span>) }
  | expr BITOR expr         { Binop($<span class="hljs-number">1</span>, BitOr, $<span class="hljs-number">3</span>) }
  | expr LSHIFT expr        { Binop($<span class="hljs-number">1</span>, Lshift, $<span class="hljs-number">3</span>) }
  | expr RSHIFT expr        { Binop($<span class="hljs-number">1</span>, Rshift, $<span class="hljs-number">3</span>) }

  <span class="hljs-comment">/* Query */</span>
  | expr QUERY expr         { Queryop($<span class="hljs-number">1</span>, Query, $<span class="hljs-number">3</span>, IntLit(<span class="hljs-string">"QuerySingleBit"</span>)) }
  | expr QUERY_UNREAL expr  { Queryop($<span class="hljs-number">1</span>, QueryUnreal, $<span class="hljs-number">3</span>, IntLit(<span class="hljs-string">"QuerySingleBit"</span>)) }
  | expr QUERY LSQUARE COLON expr RSQUARE { Queryop($<span class="hljs-number">1</span>, Query, IntLit(<span class="hljs-string">"0"</span>), $<span class="hljs-number">5</span>) }
  | expr QUERY_UNREAL LSQUARE COLON expr RSQUARE  { Queryop($<span class="hljs-number">1</span>, QueryUnreal, IntLit(<span class="hljs-string">"0"</span>), $<span class="hljs-number">5</span>) }
  | expr QUERY LSQUARE expr COLON expr RSQUARE         { Queryop($<span class="hljs-number">1</span>, Query, $<span class="hljs-number">4</span>, $<span class="hljs-number">6</span>) }
  | expr QUERY_UNREAL LSQUARE expr COLON expr RSQUARE  { Queryop($<span class="hljs-number">1</span>, QueryUnreal, $<span class="hljs-number">4</span>, $<span class="hljs-number">6</span>) }

  <span class="hljs-comment">/* Parenthesis */</span>
  | LPAREN expr RPAREN { $<span class="hljs-number">2</span> }

  <span class="hljs-comment">/* Assignment */</span>
  | lvalue ASSIGN expr { Assign($<span class="hljs-number">1</span>, $<span class="hljs-number">3</span>) }
  | lvalue             { Lval($<span class="hljs-number">1</span>) }

  <span class="hljs-comment">/* Special assignment */</span>
  | lvalue PLUS_EQUALS expr { AssignOp($<span class="hljs-number">1</span>, AddEq, $<span class="hljs-number">3</span>) }
  | lvalue MINUS_EQUALS expr { AssignOp($<span class="hljs-number">1</span>, SubEq, $<span class="hljs-number">3</span>) } 
  | lvalue TIMES_EQUALS expr { AssignOp($<span class="hljs-number">1</span>, MulEq, $<span class="hljs-number">3</span>) }
  | lvalue DIVIDE_EQUALS expr { AssignOp($<span class="hljs-number">1</span>, DivEq, $<span class="hljs-number">3</span>) }
  | lvalue BITAND_EQUALS expr { AssignOp($<span class="hljs-number">1</span>, BitAndEq, $<span class="hljs-number">3</span>) }

  <span class="hljs-comment">/* Post operation */</span>
  | lvalue INCREMENT { PostOp($<span class="hljs-number">1</span>, Inc) }
  | lvalue DECREMENT { PostOp($<span class="hljs-number">1</span>, Dec) }

  <span class="hljs-comment">/* Membership testing with keyword 'in' */</span>
  | expr IN expr    { Membership($<span class="hljs-number">1</span>, $<span class="hljs-number">3</span>) }

  <span class="hljs-comment">/* literals */</span>
  | INT_LITERAL                                 { IntLit($<span class="hljs-number">1</span>) }
  | FLOAT_LITERAL                               { FloatLit($<span class="hljs-number">1</span>) }
  | BOOLEAN_LITERAL                             { BoolLit($<span class="hljs-number">1</span>) }
  | expr DOLLAR expr                            { FractionLit($<span class="hljs-number">1</span>, $<span class="hljs-number">3</span>) }
  | STRING_LITERAL                              { StringLit($<span class="hljs-number">1</span>) }
  | LSQUARE expr_list RSQUARE                   { ArrayLit($<span class="hljs-number">2</span>) }
  | datatype LSQUARE expr RSQUARE               { ArrayCtor($<span class="hljs-number">1</span>, $<span class="hljs-number">3</span>) }
  | LMATRIX matrix_row_list RMATRIX             { MatrixLit($<span class="hljs-number">2</span>) }
  | datatype LMATRIX expr COMMA expr RMATRIX { MatrixCtor($<span class="hljs-number">1</span>, $<span class="hljs-number">3</span>, $<span class="hljs-number">5</span>) }
  | COMPLEX_SYM expr COMMA expr RPAREN          { ComplexLit($<span class="hljs-number">2</span>, $<span class="hljs-number">4</span>) }
  | COMPLEX_SYM expr RPAREN                     { ComplexLit($<span class="hljs-number">2</span>, FloatLit(<span class="hljs-string">"0.0"</span>)) }
  | LQREG expr COMMA expr RQREG                 { QRegLit($<span class="hljs-number">2</span>, $<span class="hljs-number">4</span>) }

  <span class="hljs-comment">/* function call */</span>
  | ident LPAREN RPAREN             { FunctionCall($<span class="hljs-number">1</span>, []) }
  | ident LPAREN expr_list RPAREN   { FunctionCall ($<span class="hljs-number">1</span>, $<span class="hljs-number">3</span>) }

expr_list:
  | expr COMMA expr_list { $<span class="hljs-number">1</span> :: $<span class="hljs-number">3</span> }
  | expr                 { [$<span class="hljs-number">1</span>] }

<span class="hljs-comment">/* [| r00, r01; r10, r11; r20, r21 |] */</span>
matrix_row_list:
  | expr_list SEMICOLON matrix_row_list { $<span class="hljs-number">1</span> :: $<span class="hljs-number">3</span> }
  | expr_list            { [$<span class="hljs-number">1</span>] }

decl:
  | datatype ident ASSIGN expr SEMICOLON                { AssigningDecl($<span class="hljs-number">1</span>, $<span class="hljs-number">2</span>, $<span class="hljs-number">4</span>) }
  | datatype ident SEMICOLON                            { PrimitiveDecl($<span class="hljs-number">1</span>, $<span class="hljs-number">2</span>) }

statement:
  | IF expr COLON statement ELSE statement
      { IfStatement($<span class="hljs-number">2</span>, $<span class="hljs-number">4</span>, $<span class="hljs-number">6</span>) }
  | IF expr COLON statement %prec IFX
      { IfStatement($<span class="hljs-number">2</span>, $<span class="hljs-number">4</span>, EmptyStatement) }

  | WHILE expr COLON statement { WhileStatement($<span class="hljs-number">2</span>, $<span class="hljs-number">4</span>) }
  | FOR iterator COLON statement { ForStatement($<span class="hljs-number">2</span>, $<span class="hljs-number">4</span>) }

  | LCURLY statement_seq RCURLY { CompoundStatement($<span class="hljs-number">2</span>) }

  | expr SEMICOLON { Expression($<span class="hljs-number">1</span>) }
  | SEMICOLON { EmptyStatement }
  | decl { Declaration($<span class="hljs-number">1</span>) }

  | RETURN expr SEMICOLON { ReturnStatement($<span class="hljs-number">2</span>) }
  | RETURN SEMICOLON { VoidReturnStatement }

  <span class="hljs-comment">/* Control flow */</span>
  | BREAK { BreakStatement }
  | CONTINUE { ContinueStatement }

iterator:
  | ident IN LSQUARE range RSQUARE { RangeIterator(NoneType, $<span class="hljs-number">1</span>, $<span class="hljs-number">4</span>) }
  | datatype ident IN LSQUARE range RSQUARE { RangeIterator($<span class="hljs-number">1</span>, $<span class="hljs-number">2</span>, $<span class="hljs-number">5</span>) }
  | datatype ident IN expr { ArrayIterator($<span class="hljs-number">1</span>, $<span class="hljs-number">2</span>, $<span class="hljs-number">4</span>) }

range:
  | expr COLON expr COLON expr { Range($<span class="hljs-number">1</span>, $<span class="hljs-number">3</span>, $<span class="hljs-number">5</span>) }
  | expr COLON expr { Range($<span class="hljs-number">1</span>, $<span class="hljs-number">3</span>, IntLit(<span class="hljs-string">"1"</span>)) }
  | COLON expr COLON expr { Range(IntLit(<span class="hljs-string">"0"</span>), $<span class="hljs-number">2</span>, $<span class="hljs-number">4</span>) }
  | COLON expr { Range(IntLit(<span class="hljs-string">"0"</span>), $<span class="hljs-number">2</span>, IntLit(<span class="hljs-string">"1"</span>)) }

top_level_statement:
  | DEF datatype ident COLON param_list LCURLY statement_seq RCURLY
      { FunctionDecl($<span class="hljs-number">2</span>, $<span class="hljs-number">3</span>, $<span class="hljs-number">5</span>, $<span class="hljs-number">7</span>) }
  | datatype ident COLON param_list SEMICOLON
      { ForwardDecl($<span class="hljs-number">1</span>, $<span class="hljs-number">2</span>, $<span class="hljs-number">4</span>) }
  | decl { Declaration($<span class="hljs-number">1</span>) }

param:
  | datatype ident { PrimitiveDecl($<span class="hljs-number">1</span>, $<span class="hljs-number">2</span>) }

non_empty_param_list:
  | param COMMA non_empty_param_list { $<span class="hljs-number">1</span> :: $<span class="hljs-number">3</span> }
  | param { [$<span class="hljs-number">1</span>] }

param_list:
  | non_empty_param_list { $<span class="hljs-number">1</span> }
  | { [] }

top_level:
  | top_level_statement top_level {$<span class="hljs-number">1</span> :: $<span class="hljs-number">2</span>}
  | top_level_statement { [$<span class="hljs-number">1</span>] }

statement_seq:
  | statement statement_seq {$<span class="hljs-number">1</span> :: $<span class="hljs-number">2</span> }
  | { [] }</code></pre></div></body>
</html>